!function(exports) {
    "use strict";
    function isUndefined(value) {
        return "undefined" == typeof value;
    }
    function isDefined(value) {
        return "undefined" != typeof value;
    }
    function isObject(value) {
        return null != value && "object" == typeof value;
    }
    function isString(value) {
        return "string" == typeof value;
    }
    function isNumber(value) {
        return "number" == typeof value;
    }
    function isDate(value) {
        return "[object Date]" == toString.apply(value);
    }
    function isArray(value) {
        return "[object Array]" == toString.apply(value);
    }
    function isFunction(value) {
        return "function" == typeof value;
    }
    function isBoolean(value) {
        return "boolean" == typeof value;
    }
    function size(obj, ownPropsOnly) {
        var key, count = 0;
        if (isArray(obj) || isString(obj)) return obj.length;
        if (isObject(obj)) {
            for (key in obj) (!ownPropsOnly || obj.hasOwnProperty(key)) && count++;
            return count;
        }
    }
    var idCounter = 0;
    "undefined" == typeof exports.kg && (exports.kg = {}), kg.uniqueId = function() {
        return idCounter++;
    }, kg.log = function(msg, data) {
        "undefined" != typeof console && console.log(msg, data);
    }, kg.extend = function(obj1, obj2) {
        var key = null;
        for (key in obj2) obj1[key] = obj2[key];
        return obj1;
    }, kg.formatTime = function(time) {
        var mm = Math.floor(time / 60), ss = Math.floor(time - 60 * mm), mins = 10 > mm ? "0" + mm : mm, secs = 10 > ss ? "0" + ss : ss;
        return mins + ":" + secs;
    }, kg.getQueryString = function(key, defaultValue) {
        null === defaultValue && (defaultValue = ""), key = key.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
        var regex = new RegExp("[\\?&amp;]" + key + "=([^&amp;#]*)"), qs = regex.exec(window.location.href);
        return null == qs ? defaultValue : qs[1];
    }, kg.size = size, kg.isUndefined = isUndefined, kg.isDefined = isDefined, kg.isObject = isObject, 
    kg.isString = isString, kg.isNumber = isNumber, kg.isDate = isDate, kg.isArray = isArray, 
    kg.isFunction = isFunction, kg.isBoolean = isBoolean;
}(window), function(exports, kg) {
    "use strict";
    function Watcher(obj, prop, fn) {
        this.id = kg.uniqueId(), this.oldVal = obj[prop], this.obj = obj, this.prop = prop, 
        this.callback = fn;
    }
    function clearWatcher(id) {
        var i = 0, len = watchers.length, index = -1;
        for (i = 0; len > i; i++) if (watchers[i].id === id) {
            index = i;
            break;
        }
        index > -1 && watchers.splice(index, 1);
    }
    function watch(obj, prop, fn) {
        var newWatcher = new Watcher(obj, prop, fn);
        return newWatcher.apply(), watchers.push(newWatcher), newWatcher.id;
    }
    function apply(fn) {
        function loop() {
            var i = 0, len = watchers.length;
            for (isLooping = !0, i = 0; len > i; i++) changed = watchers[i].check(), changed && !rerun && (rerun = !0);
            counter++, rerun && OVERFLOW_LIMIT > counter ? (rerun = !1, loop()) : counter >= OVERFLOW_LIMIT ? (kg.log("ERROR: apply loop overflow"), 
            isLooping = !1) : isLooping = !1;
        }
        isLooping || (kg.isFunction(fn) && fn(), counter = 0, rerun = !1, changed = !1, 
        loop());
    }
    if ("undefined" != typeof kg) {
        var rerun = !1, changed = !1, watchers = [], isLooping = !1, counter = 0, OVERFLOW_LIMIT = 10;
        Watcher.prototype = {
            constructor: Watcher,
            apply: function() {
                var newVal = this.obj[this.prop];
                this.callback(newVal, this.oldVal), this.oldVal = newVal;
            },
            check: function() {
                var newVal = this.obj[this.prop];
                return this.oldVal !== newVal ? (this.apply(), !0) : !1;
            }
        }, kg.clearWatcher = clearWatcher, kg.watch = watch, kg.apply = apply;
    }
}(window, window.kg);